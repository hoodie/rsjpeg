use nom::le_u8;

use failure::Error;

use errors::ParserError;

named!(jpeg<&[u8], (Vec<&[u8]>, &[u8])>, delimited!(soi, jfif, end));
named!(soi, tag!(b"\xff\xd8"));
named!(end, tag!(b"\xff\xd9"));
named!(
    segment,
    preceded!(
        tag!(b"\xff"),
        preceded!(not!(tag!(b"\x00")), length_data!(le_u8))
    )
);
named!(jfif<&[u8], (Vec<&[u8]>, &[u8])>, many_till!(segment, end));

pub fn decode(jpeg_file: &[u8]) -> Result<Vec<u8>, Error> {
    jpeg(jpeg_file)
        .map(|parsed_correctly| paste(&(parsed_correctly.1).0))
        .map_err(|e| ParserError {
            reason: format!("{:?}", e),
        }.into())
}

fn paste(_segments: &Vec<&[u8]>) -> Vec<u8> {
    vec![]
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn decode_test() {
        let minimal_jpeg = vec![
            0xFF, 0xD8, 0xFF, 0xDB, 0x00, 0x43, 0x00, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03,
            0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x06, 0x04, 0x04, 0x04, 0x04, 0x04,
            0x08, 0x06, 0x06, 0x05, 0x06, 0x09, 0x08, 0x0A, 0x0A, 0x09, 0x08, 0x09, 0x09, 0x0A,
            0x0C, 0x0F, 0x0C, 0x0A, 0x0B, 0x0E, 0x0B, 0x09, 0x09, 0x0D, 0x11, 0x0D, 0x0E, 0x0F,
            0x10, 0x10, 0x11, 0x10, 0x0A, 0x0C, 0x12, 0x13, 0x12, 0x10, 0x13, 0x0F, 0x10, 0x10,
            0x10, 0xFF, 0xC9, 0x00, 0x0B, 0x08, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x11, 0x00,
            0xFF, 0xCC, 0x00, 0x06, 0x00, 0x10, 0x10, 0x05, 0xFF, 0xDA, 0x00, 0x08, 0x01, 0x01,
            0x00, 0x00, 0x3F, 0x00, 0xD2, 0xCF, 0x20, 0xFF, 0xD9,
        ];

        assert_eq!(decode(&minimal_jpeg[..]).unwrap(), minimal_jpeg);
    }
}